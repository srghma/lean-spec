-- Test.Spec.Runner module translated to Lean 4
import Std.Data.Array.Basic
import Std.Data.List.Basic
import Init.Data.Option.Basic
import Init.Control.Alternative
import Init.Control.Monad.Basic

-- Example usage and type aliases for compatibility
abbrev Spec := SpecTree
abbrev SpecT (m : Type → Type) := StateT SpecTree m

structure Path where
  segments : List String
  deriving Inhabited, Repr, DecidableEq

inductive Speed where
  | fast
  | medium
  | slow
  deriving Inhabited, Repr, DecidableEq

structure Duration where
  milliseconds : Nat
  deriving Inhabited, Repr

inductive Result where
  | success (speed : Speed) (duration : Duration)
  | failure (error : String)
  deriving Inhabited, Repr

-- Test item structure
structure Item where
  example : Unit → IO Unit
  timeout : Option Milliseconds

-- Test tree structure
inductive Tree (a : Type) (b : Type) where
  | leaf : String → Option a → Tree a b
  | node : Either String (Unit → IO Unit) → List (Tree a b) → Tree a b
  deriving Inhabited

-- Spec tree type alias
abbrev SpecTree := Tree Item Unit

-- Test execution modes
inductive Execution where
  | sequential
  | parallel
  deriving Inhabited, Repr, DecidableEq

-- Test events
inductive Event where
  | start (testCount : Nat)
  | test (execution : Execution) (path : Path × String)
  | testEnd (path : Path × String) (result : Result)
  | pending (path : Path × String)
  | suite (execution : Execution) (path : Path × String)
  | suiteEnd (path : Path × String)
  | end (results : Array (Tree String Result))
  deriving Inhabited, Repr

-- Configuration
structure Config where
  timeout : Option Milliseconds
  slow : Duration
  failFast : Bool
  exit : Bool
  filterTree : SpecTree → SpecTree

def defaultConfig : Config :=
  { timeout := some ⟨5000⟩
  , slow := ⟨75⟩
  , failFast := false
  , exit := false
  , filterTree := id }

-- Core runner types
abbrev TestEvents := IO (Array Event × Array (Tree String Result))
abbrev Reporter := Array Event → IO (Array Event)

-- Utility functions
def speedOf (slow : Duration) (duration : Duration) : Speed :=
  if duration.milliseconds >= slow.milliseconds * 2 then Speed.slow
  else if duration.milliseconds >= slow.milliseconds then Speed.medium
  else Speed.fast

def countTests : SpecTree → Nat
  | Tree.leaf _ (some _) => 1
  | Tree.leaf _ none => 0
  | Tree.node _ children => children.foldl (fun acc t => acc + countTests t) 0

def isAllParallelizable : SpecTree → Bool
  | Tree.leaf _ _ => true
  | Tree.node _ children => children.all isAllParallelizable

-- Timeout implementation
def makeTimeout (ms : Milliseconds) : IO Unit := do
  IO.sleep ms.value.toUInt32
  throw (IO.userError s!"test timed out after {ms.value}ms")

def withTimeout (time : Milliseconds) (computation : IO α) : IO α := do
  let timeoutTask ← IO.asTask (makeTimeout time)
  let computationTask ← IO.asTask computation

  -- This is a simplified version - in practice you'd want proper race semantics
  let result ← IO.wait computationTask
  IO.cancel timeoutTask
  return result

-- Path annotation
structure TestWithPath where
  test : SpecTree
  path : Path

def annotatedWithPaths (tests : SpecTree) : Array TestWithPath :=
  let rec go (currentPath : Path) (tree : SpecTree) : Array TestWithPath :=
    match tree with
    | Tree.leaf name item =>
        #[⟨Tree.leaf name item, currentPath⟩]
    | Tree.node (Either.left suiteName) children =>
        let newPath := ⟨currentPath.segments ++ [suiteName]⟩
        children.toArray.foldl (fun acc child => acc ++ go newPath child) #[]
    | Tree.node (Either.right _) children =>
        children.toArray.foldl (fun acc child => acc ++ go currentPath child) #[]
  go ⟨[]⟩ tests

-- Group tests by parallelizability
def groupByParallelizable (tests : Array TestWithPath) : Array (Array TestWithPath) :=
  let groups := tests.foldl (fun acc test =>
    let isParallel := isAllParallelizable test.test
    match acc.findIdx? (fun group =>
      match group.get? 0 with
      | some first => isAllParallelizable first.test == isParallel
      | none => false) with
    | some idx => acc.set! idx (acc[idx]! ++ #[test])
    | none => acc ++ #[#[test]]
  ) #[]
  groups.filter (fun g => !g.isEmpty)

-- Execute a single test example
def executeExample (config : Config) (example : Unit → IO Unit) : IO Result := do
  let startTime ← IO.monoMsNow
  let computation := example ()

  let result ← match config.timeout with
    | some timeout =>
        try
          withTimeout timeout computation
          return none
        catch e =>
          return some e.toString
    | none =>
        try
          computation
          return none
        catch e =>
          return some e.toString

  let endTime ← IO.monoMsNow
  let duration := ⟨endTime - startTime⟩

  match result with
  | some error => return Result.failure error
  | none => return Result.success (speedOf config.slow duration) duration

-- Run parallel tasks
def runParallelTasks (tasks : Array (IO α)) : IO (Array α) := do
  let taskArray ← tasks.mapM IO.asTask
  taskArray.mapM IO.wait

-- Main runner implementation
def runItem (config : Config) (keepRunning : IO.Ref Bool) (testWithPath : TestWithPath) : IO (Array Event × Array (Tree String Result)) := do
  let running ← keepRunning.get
  if !running then
    return (#[], #[Tree.leaf "skipped" none])

  match testWithPath.test with
  | Tree.leaf name (some item) => do
      let path := testWithPath.path
      let isParallel := isAllParallelizable testWithPath.test
      let execution := if isParallel then Execution.parallel else Execution.sequential

      let events := #[Event.test execution (path, name)]
      let result ← executeExample config item.example

      -- Handle fail fast
      match result with
      | Result.failure _ =>
          if config.failFast then
            keepRunning.set false
      | _ => pure ()

      let endEvents := #[Event.testEnd (path, name) result]
      let resultTree := #[Tree.leaf name (some result)]

      return (events ++ endEvents, resultTree)

  | Tree.leaf name none => do
      let path := testWithPath.path
      let events := #[Event.pending (path, name)]
      let resultTree := #[Tree.leaf name none]
      return (events, resultTree)

  | Tree.node (Either.left suiteName) children => do
      let path := testWithPath.path
      let isParallel := isAllParallelizable testWithPath.test
      let execution := if isParallel then Execution.parallel else Execution.sequential

      let startEvents := #[Event.suite execution (path, suiteName)]

      -- Process children
      let childTests := annotatedWithPaths (Tree.node (Either.left suiteName) children)
      let (childEvents, childResults) ← runTests config keepRunning childTests

      let endEvents := #[Event.suiteEnd (path, suiteName)]
      let resultTree := #[Tree.node (Either.left suiteName) childResults.toList]

      return (startEvents ++ childEvents ++ endEvents, resultTree)

  | Tree.node (Either.right cleanup) children => do
      -- Process children then run cleanup
      let childTests := annotatedWithPaths (Tree.node (Either.right cleanup) children)
      let (events, results) ← runTests config keepRunning childTests
      cleanup ()
      return (events, results)

-- Run multiple tests
partial def runTests (config : Config) (keepRunning : IO.Ref Bool) (tests : Array TestWithPath) : IO (Array Event × Array (Tree String Result)) := do
  let groups := groupByParallelizable tests
  let mut allEvents : Array Event := #[]
  let mut allResults : Array (Tree String Result) := #[]

  for group in groups do
    if group.isEmpty then continue

    let isParallel := match group.get? 0 with
      | some first => isAllParallelizable first.test
      | none => false

    if isParallel then
      -- Run in parallel
      let tasks := group.map (runItem config keepRunning)
      let results ← runParallelTasks tasks
      for (events, treeResults) in results do
        allEvents := allEvents ++ events
        allResults := allResults ++ treeResults
    else
      -- Run sequentially
      for test in group do
        let (events, treeResults) ← runItem config keepRunning test
        allEvents := allEvents ++ events
        allResults := allResults ++ treeResults

  return (allEvents, allResults)

-- Main entry point
def run (config : Config) (reporters : Array Reporter) (spec : SpecTree) : IO (Array (Tree String Result)) := do
  let testCount := countTests spec
  let keepRunning ← IO.mkRef true

  let startEvent := Event.start testCount
  let tests := annotatedWithPaths spec

  let (events, results) ← runTests config keepRunning tests
  let endEvent := Event.end results

  let allEvents := #[startEvent] ++ events ++ #[endEvent]

  -- Apply reporters
  let mut processedEvents := allEvents
  for reporter in reporters do
    processedEvents ← reporter processedEvents

  return results

-- Convenience functions
def runSpec (reporters : Array Reporter) (spec : SpecTree) : IO Unit := do
  let _ ← run defaultConfig reporters spec
  return ()

def runSpec' (config : Config) (reporters : Array Reporter) (spec : SpecTree) : IO Unit := do
  let _ ← run config reporters spec
  return ()

def runSpecPure (reporters : Array Reporter) (spec : SpecTree) : IO Unit :=
  runSpec reporters spec

def runSpecPure' (config : Config) (reporters : Array Reporter) (spec : SpecTree) : IO Unit :=
  runSpec' config reporters spec

-- Helper for checking if all tests passed
def successful (results : Array (Tree String Result)) : Bool :=
  let rec checkTree : Tree String Result → Bool
    | Tree.leaf _ (some (Result.success _ _)) => true
    | Tree.leaf _ (some (Result.failure _)) => false
    | Tree.leaf _ none => true -- pending tests don't count as failures
    | Tree.node _ children => children.all checkTree
  results.all checkTree
